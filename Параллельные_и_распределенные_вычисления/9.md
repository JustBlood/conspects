```
Параллельные и распределенные вычисления.
```
**Простой клиент**

**Клиент** также является консольным приложением C#. Тут так же делается ссылка на сборку
System.Runtime.Remoting.dll, чтобы можно было использовать класс TcpClientChannel, кроме того,
имеется ссылка на сборку RemoteHello.dll, хотя объект будет создаваться на удаленном сервере,
нам понадобится сборка на стороне клиента, чтобы Proxy прочитал метаданные во время
выполнения. В клиентской программе создается объект TcpClientChannel, который регистрируется
в ChannelServices. Для TcpChannel используется конструктор по умолчанию, поэтому выбирается
свободный порт, затем используется класс Activator для возврата Proxy удаленном объекту. Proxy
является типом System.Runtime.Remoting.Proxies.TransparentProxy этот объект выглядит как
реальный, это делается с помощью механизма отражения в котором считываются метаданные
реального объекта, прозрачный прокси использует реальный объект для пересылки сообщений в
канал.

```
using System;

using System.Runtime.Remoting.Channels;

using System.Runtime.Remoting.Channels.TCP;

using RemoteHello;

namespace MyProgram {

public class HelloClient {

public static void Main(string[] args) {

ChannelServices.RegisterChannel(new TcpClientChannel());

Hello obj = (Hello) Activator.GetObject(typeof(Hello),

“tcp://localhost:8086/Hi”);

If (obj == null) {

Console.WriteLine(“не удалось подключиться”);

return;

}

for (int i = 0; i < 5; i++) {

Console.WriteLine(obj.Greeting(“Иван”));

}

}

}

}
```


[< Previous](8.md) | [Next >](10.md)