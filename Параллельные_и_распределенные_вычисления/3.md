```
Параллельные и распределенные вычисления.
```
Свойство потока **IsAlive** , указывает работает ли поток в текущий момент. Это свойство принимает
значение true, если этот поток был запущен и не был завершен обычным образом, либо прерван.
В противном случае значение false.

Свойство **ThreadState** состояние потока, возвращает состояние потока, одно из значений
перечисления ThreadState. Статусы потока содержатся в перечислении ThreadState:

1. Aborted – в этом случае поток остановлен, но пока еще окончательно не завершен
2. AbortRequested – для потока вызван метод abort, но остановка пока еще не произошла
3. Background – поток выполняется в фоновом режиме
4. Running – поток выполняется (основной поток)
5. Stopped – поток завершен
6. StopRequesting – поток получил запрос на остановку
7. Suspended
8. SuspendRequested – поток получил запрос на приостановку
9. Unstarted – не запущен
10. WaitSleepJoin – поток ожидает

В процессе работы потока, его статус многократно может смениться под действием методов

**Синхронизация потоков**

Одним из важных аспектов работы с потоками является синхронизация доступа к переменным со
стороны нескольких потоков. Под синхронизацией понимается то, что только один поток должен
получить доступ к переменной в данный момент времени. Если это требование не соблюдается, в
программе могут появиться трудно обнаруживаемые ошибки. Проблема синхронизации
возникает по той причине, что то что в C# выглядит как один оператор, в окончательной сборке
как правило транслируется в множество операторов (множество процессорных инструкций).

К счастью, C# обеспечивает простой способ синхронизации доступа к переменной, с помощью
ключевого слова **lock** :

lock(x) {

//выполняемые действия

}

Оператор lock использует объект известный как взаимноисключающая блокировка или
Mutex(Мьютекс).

Мьютекс существует до тех пор, пока выполняется составной оператор, указывая для ключевого
оператора lock. Пока переменная блокирована, другой поток не может получить к ней доступ.
Если во время исполнения приведенного кода, процесс теряет квант времени, а другой процесс
получает его и пытается осуществить доступ к переменной, ему будет отказано в доступе.
Windows приостановит другой поток до того момента, как Мьютекс будет освобожден.
Существуют и другие механизмы, для управления доступа к переменным, все они используются с
помощью базового класса .Net – System.Threading. В целом переменные необходимо
синхронизировать, если существует риск того, что поток может записывать в переменную тогда,
когда другие потоки пытаются записать или прочитать ту же самую переменную.

**Проблемы синхронизации**


1. **Злоупотребление синхронизацией.** Синхронизация потоков должна использоваться
    только тогда, когда это действительно необходимо, поскольку она может серьезно
    ухудшить производительность. Во-первых lock, понижает производительность на время
    установки и снятия блокировки. Во-вторых, в блоке lock, по сути, идет однопоточная
    операция, поэтому помещать нужно минимальное количество кода.
2. **Блокировка** является ошибкой, которая может возникнуть, когда два потока пытаются
    получить доступ к ресурсам, блокированным друг другом

```
Рисунок 1. Взаимная блокировка, потоки вечно ждут друг друга.
```
Блокировки обычно не возникают, когда потоки захватывают объекты в одной
последовательности.

```
Рисунок 2. Последовательная блокировка, ошибки нету.
```
Блокировки могут также возникать в различных вызовах методов. Эти методы могут вызывать и
другие методы, где внутри них может встречаться оператор lock(B). В этой ситуации возможность
взаимной блокировки уже не так очевидна.

3. **Состязание.** Состязание происходит тогда, когда несколько потоков пытаются получить
    доступ к одним и тем же данным и не принимают во внимание то, что при этом делают
    другие потоки

```
lock(A) {
...
lock(B) {
...
}
}
lock(B) {
...
lock(A) {
...
}
}
lock(A) {
...
lock(B) {
...
}
}
lock(A) {
...
lock(B) {
...
}
}
```

