```
Параллельные и распределенные вычисления.
```
**Создание распределенных приложений с помощью .NET Remoting**

**Обзор .NET Remoting**

.NET Remoting может использоваться для доступа к объектам в домене другого приложения, не
зависимо от того, находится ли два объекта внутри одного процесса, в разных процессах или на
разных системах. Удаленные сборки можно сконфигурировать для локальной работы в домене
приложения. Или как часть удаленного приложения. Если сборка является частью удаленного
приложения, то клиент получает, для общения прокси вместо реального объекта, прокси
посылает сообщение в канал.

**Основные элементы архитектуры .NET Remoting**

1. **Удаленный объект.** Является объектом, который выполняется на сервере. Клиент не
    вызывает методы на этом объекте напрямую, а использует для этого прокси, с помощью
    .NET, легко отличить удаленный объект от локальных, каждый класс производный от
    MarshalByValueObject. Никогда не покидает свой домен приложений, клиент может
    вызывать методы на удаленном объекте через Proxy.
2. **Канал.** Используется для коммуникаций между клиентом и сервером. Существует
    клиентская и серверная часть канала, с помощью .NET Framework, на протоколе TCP/HTTP,
    можно так же создать специальный канал, который поддерживает связь с помощью
    другого протокола.
3. **Сообщения.** Посылаются в канал, создаются для коммуникаций между клиентом и
    сервером. И хранят информацию об удаленных объектах, именах вызванных методов и
    всех аргументов.
4. **Форматтер.** Определяет как сообщения передаются в канал. SOAP, двоичный. SOAP –
    можно использовать для связи со службами WeB которые не основываются на .NET
    Framework. Двоичные форматтеры действуют значительно быстрее и могут быстрее
    использоваться в среде intranet. Конечно, имеется возможность создать специальный
    форматтер
5. **Провайдер форматтер.** Используются для соединения форматтера с каналом, создавая
    канал можно выбрать провайдер форматтера и этот выбор в свою очередь определяет
    форматтер, который будет использоваться для передачи в канал.
6. **Клиент.** Вызывает методы на прокси, а не на удаленном объекте. Существует 2 типа
    прокси:
       a. **Прозрачный прокси.** Выглядит для клиента как удаленный объект, клиент может
          вызвать методы, реализуемые удаленным объектом на прозрачном прокси. В свою
          очередь прозрачный прокси вызывает метод Invoke(), на реальном прокси для
          передачи сообщения в канал.
       b. **Реальный прокси**
7. **Приемник сообщений.** Является объектом перехватчиком. Такие перехватчики имеются
    как на клиенте, так и на сервере. Реальный прокси использует его для передачи
    сообщения в канал, поэтому приемник осуществляет некоторый перехват прежде, чем
    сообщения попадают в канал
8. **Активатор.** Клиент может использовать активатор для создания удаленного объекта на
    сервере или для получения прокси активированного сервера объекта.
9. **Remoting Configuration** – является служебным классом для конфигурирования удаленных
    серверов и клиентов. Этот класс используется для чтения конфигурационных файлов или
    для динамического конфигурирования удаленных объектов.


10. **Chanel Services**. Является служебным классом для регистрации каналов и затем для
    отправки сообщения в канал.


